<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>postgresql.rdoc</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>postgresql.rdoc
</h1>
<div class='paths'>
doc/postgresql.rdoc
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-PostgreSQL-specific+Support+in+Sequel">PostgreSQL-specific Support in <a href="../../classes/Sequel.html"><code>Sequel</code></a><span><a href="#label-PostgreSQL-specific+Support+in+Sequel">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Sequel’s core database and dataset functions are designed to support the features shared by most common SQL database implementations.  However, Sequel’s database adapters extend the core support to include support for database-specific features.</p>

<p>By far the most extensive database-specific support in <a href="../../classes/Sequel.html"><code>Sequel</code></a> is for PostgreSQL. This support is roughly broken into the following areas:</p>
<ul><li>
<p>Database Types</p>
</li><li>
<p>DDL Support</p>
</li><li>
<p>DML Support</p>
</li><li>
<p>sequel_pg</p>
</li></ul>

<p>Note that while this guide is extensive, it is not exhaustive.  There are additional rarely used PostgreSQL features that <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports which are not mentioned here.</p>

<h2 id="label-Adapter-2FDriver+Specific+Support">Adapter/Driver Specific Support<span><a href="#label-Adapter-2FDriver+Specific+Support">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Some of this this support depends on the specific adapter or underlying driver in use.</p>

<p><code>postgres only</code> will denote support specific to the postgres adapter (i.e. not available when connecting to PostgreSQL via the jdbc adapter). <code>postgres/pg only</code> will denote support specific to the postgres adapter when pg is used as the underlying driver (i.e. not available when using the postgres-pr driver).</p>

<h2 id="label-PostgreSQL-specific+Database+Type+Support">PostgreSQL-specific Database Type Support<span><a href="#label-PostgreSQL-specific+Database+Type+Support">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Sequel’s default support on PostgreSQL only includes common database types.  However, <a href="../../classes/Sequel.html"><code>Sequel</code></a> ships with support for many PostgreSQL-specific types via extensions.  In general, you load these extensions via <code>Database#extension</code>.  For example, to load support for arrays, you would do:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:pg_array</span>
</pre>

<p>The following PostgreSQL-specific type extensions are available:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>pg_array </td><td>
<p>arrays (single and multidimensional, for any scalar type), as a ruby Array-like object</p>
</td></tr><tr><td class='label'>pg_hstore </td><td>
<p>hstore, as a ruby Hash-like object</p>
</td></tr><tr><td class='label'>pg_inet </td><td>
<p>inet/cidr, as ruby IPAddr objects</p>
</td></tr><tr><td class='label'>pg_interval </td><td>
<p>interval, as ActiveSupport::Duration objects</p>
</td></tr><tr><td class='label'>pg_json </td><td>
<p>json, as either ruby Array-like or Hash-like objects</p>
</td></tr><tr><td class='label'>pg_range </td><td>
<p>ranges (for any scalar type), as a ruby Range-like object</p>
</td></tr><tr><td class='label'>pg_row </td><td>
<p>row-valued/composite types, as a ruby Hash-like or <a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a> object</p>
</td></tr></tbody></table>

<p>In general, these extensions just add support for Database objects to return retrieved column values as the appropriate type and support for literalizing the objects correctly for use in an SQL string, or using them as bound variable values (<code>postgres/pg and jdbc/postgres only</code>).</p>

<p>There are also type-specific extensions that make it easy to use database functions and operators related to the type.  These extensions are:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>pg_array_ops </td><td>
<p>array-related functions and operators</p>
</td></tr><tr><td class='label'>pg_hstore_ops </td><td>
<p>hstore-related functions and operators</p>
</td></tr><tr><td class='label'>pg_json_ops </td><td>
<p>json-related functions and operators</p>
</td></tr><tr><td class='label'>pg_range_ops </td><td>
<p>range-related functions and operators</p>
</td></tr><tr><td class='label'>pg_row_ops </td><td>
<p>row-valued/composite type syntax support</p>
</td></tr></tbody></table>

<p>These extensions aren’t Database specific, they are global extensions, so you should load them via <code>Sequel.extension</code>, after loading support for the specific types into the Database instance:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:pg_array</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:pg_array_ops</span>
</pre>

<p>With regard to common database types, please note that the generic String type is <code>text</code> on PostgreSQL and not <code>varchar(255)</code> as it is on some other databases.  <code>text</code> is PostgreSQL’s recommended type for storage of text data, and is more similar to Ruby’s String type as it allows for unlimited length. If you want to set a maximum size for a text column, you must specify a <code>:size</code> option.  This will use a <code>varchar($size)</code> type and impose a maximum size for the column.</p>

<h2 id="label-PostgreSQL-specific+DDL+Support">PostgreSQL-specific DDL Support<span><a href="#label-PostgreSQL-specific+DDL+Support">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Exclusion+Constraints">Exclusion Constraints<span><a href="#label-Exclusion+Constraints">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In <code>create_table</code> blocks, you can use the <code>exclude</code> method to set up exclusion constraints:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">daterange</span> <span class="ruby-value">:during</span>
  <span class="ruby-identifier">exclude</span>([[<span class="ruby-value">:during</span>, <span class="ruby-string">&#39;&amp;&amp;&#39;</span>]], <span class="ruby-value">name:</span> <span class="ruby-value">:table_during_excl</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># CREATE TABLE &quot;table&quot; (&quot;during&quot; daterange,</span>
<span class="ruby-comment">#   CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;))</span>
</pre>

<p>You can also add exclusion constraints in <code>alter_table</code> blocks using add_exclusion_constraint:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(<span class="ruby-value">:table</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_exclusion_constraint</span>([[<span class="ruby-value">:during</span>, <span class="ruby-string">&#39;&amp;&amp;&#39;</span>]], <span class="ruby-value">name:</span> <span class="ruby-value">:table_during_excl</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;)</span>
</pre>

<h3 id="label-Adding+Foreign+Key+and+Check+Constraints+Without+Initial+Validation">Adding Foreign Key and Check Constraints Without Initial Validation<span><a href="#label-Adding+Foreign+Key+and+Check+Constraints+Without+Initial+Validation">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can add a <code>not_valid: true</code> option when adding constraints to existing tables so that it doesn’t check if all current rows are valid:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(<span class="ruby-value">:table</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># Assumes t_id column already exists</span>
  <span class="ruby-identifier">add_foreign_key</span>([<span class="ruby-value">:t_id</span>], <span class="ruby-value">:table</span>, <span class="ruby-value">not_valid:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">name:</span> <span class="ruby-value">:table_fk</span>)

  <span class="ruby-identifier">constraint</span>({<span class="ruby-value">name:</span> <span class="ruby-value">:col_123</span>, <span class="ruby-value">not_valid:</span> <span class="ruby-keyword">true</span>}, <span class="ruby-value">col:</span> [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>])
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_fk&quot; FOREIGN KEY (&quot;t_id&quot;) REFERENCES &quot;table&quot; NOT VALID</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;col_123&quot; CHECK (col IN (1, 2, 3)) NOT VALID</span>
</pre>

<p>Such constraints will be enforced for newly inserted and updated rows, but not for existing rows. After all existing rows have been fixed, you can validate the constraint:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(<span class="ruby-value">:table</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">validate_constraint</span>(<span class="ruby-value">:table_fk</span>)
  <span class="ruby-identifier">validate_constraint</span>(<span class="ruby-value">:col_123</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; VALIDATE CONSTRAINT &quot;table_fk&quot;</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; VALIDATE CONSTRAINT &quot;col_123&quot;</span>
</pre>

<h3 id="label-Creating+Indexes+Concurrently">Creating Indexes Concurrently<span><a href="#label-Creating+Indexes+Concurrently">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can create indexes concurrently using the <code>concurrently: true</code> option:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">add_index</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">:t_id</span>, <span class="ruby-value">concurrently:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># CREATE INDEX CONCURRENTLY &quot;table_t_id_index&quot; ON &quot;table&quot; (&quot;t_id&quot;)</span>
</pre>

<p>Similarly, you can drop indexes concurrently as well:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_index</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">:t_id</span>, <span class="ruby-value">concurrently:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># DROP INDEX CONCURRENTLY &quot;table_t_id_index&quot;</span>
</pre>

<h3 id="label-Specific+Conversions+When+Altering+Column+Types">Specific Conversions When Altering Column Types<span><a href="#label-Specific+Conversions+When+Altering+Column+Types">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When altering a column type, PostgreSQL allows the user to specify how to do the conversion via a USING clause, and <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports this using the <code>:using</code> option:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(<span class="ruby-value">:table</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># Assume unix_time column is stored as an integer, and you want to change it to timestamp</span>
  <span class="ruby-identifier">set_column_type</span> <span class="ruby-value">:unix_time</span>, <span class="ruby-constant">Time</span>, <span class="ruby-value">using:</span> (<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">&#39;epoch&#39;</span>, <span class="ruby-constant">Time</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">&#39;1 second&#39;</span>, <span class="ruby-value">:interval</span>) <span class="ruby-operator">*</span> <span class="ruby-value">:unix_time</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ALTER COLUMN &quot;unix_time&quot; TYPE timestamp</span>
<span class="ruby-comment">#   USING (CAST(&#39;epoch&#39; AS timestamp) + (CAST(&#39;1 second&#39; AS interval) * &quot;unix_time&quot;))</span>
</pre>

<h3 id="label-Creating+Partitioned+Tables">Creating Partitioned Tables<span><a href="#label-Creating+Partitioned+Tables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>PostgreSQL allows marking tables as partitioned tables, and adding partitions to such tables. <a href="../../classes/Sequel.html"><code>Sequel</code></a> offers support for this.  You can create a partitioned table using the <code>:partition_by</code> option and <code>:partition_type</code> options (the default partition type is range partitioning):</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table1</span>, <span class="ruby-value">partition_by:</span> <span class="ruby-value">:column</span>, <span class="ruby-value">partition_type:</span> <span class="ruby-value">:range</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:id</span>
  <span class="ruby-constant">Date</span> <span class="ruby-value">:column</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table2</span>, <span class="ruby-value">partition_by:</span> <span class="ruby-value">:column</span>, <span class="ruby-value">partition_type:</span> <span class="ruby-value">:list</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:id</span>
  <span class="ruby-constant">String</span> <span class="ruby-value">:column</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table3</span>, <span class="ruby-value">partition_by:</span> <span class="ruby-value">:column</span>, <span class="ruby-value">partition_type:</span> <span class="ruby-value">:hash</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:id</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:column</span>
<span class="ruby-keyword">end</span>
</pre>

<p>To add partitions of other tables, you use the <code>:partition_of</code> option.  This option will use a custom DSL specific to partitioning other tables. For range partitioning, you can use the <code>from</code> and <code>to</code> methods to specify the inclusive beginning and exclusive ending of the range of the partition.  You can call the <code>minvalue</code> and <code>maxvalue</code> methods to get the minimum and maximum values for the column(s) in the range, useful as arguments to <code>from</code> and <code>to</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table1a</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table1</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">from</span> <span class="ruby-identifier">minvalue</span>
  <span class="ruby-identifier">to</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table1b</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table1</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">from</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">to</span> <span class="ruby-value">100</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table1c</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table1</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">from</span> <span class="ruby-value">100</span>
  <span class="ruby-identifier">to</span> <span class="ruby-identifier">maxvalue</span>
<span class="ruby-keyword">end</span>
</pre>

<p>For list partitioning, you use the <code>values_in</code> method.  You can also use the <code>default</code> method to mark a partition as the default partition:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table2a</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table2</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">values_in</span> <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table2b</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table2</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">values_in</span> <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table2c</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table2</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">default</span>
<span class="ruby-keyword">end</span>
</pre>

<p>For hash partitioning, you use the <code>modulus</code> and <code>remainder</code> methods:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table3a</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table3</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">modulus</span> <span class="ruby-value">3</span>
  <span class="ruby-identifier">remainder</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table3b</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table3</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">modulus</span> <span class="ruby-value">3</span>
  <span class="ruby-identifier">remainder</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table3c</span>, <span class="ruby-value">partition_of:</span> <span class="ruby-value">:table3</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">modulus</span> <span class="ruby-value">3</span>
  <span class="ruby-identifier">remainder</span> <span class="ruby-value">2</span>
<span class="ruby-keyword">end</span>
</pre>

<p>There is currently no support for using custom column or table constraints in partitions of other tables.  Support may be added in the future.</p>

<h3 id="label-Creating+Unlogged+Tables">Creating Unlogged Tables<span><a href="#label-Creating+Unlogged+Tables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>PostgreSQL allows users to create unlogged tables, which are faster but not crash safe.  <a href="../../classes/Sequel.html"><code>Sequel</code></a> allows you to create an unlogged table by specifying the <code>unlogged: true</code> option to <code>create_table</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">unlogged:</span> <span class="ruby-keyword">true</span>){<span class="ruby-constant">Integer</span> <span class="ruby-value">:i</span>}
<span class="ruby-comment"># CREATE UNLOGGED TABLE &quot;table&quot; (&quot;i&quot; integer)</span>
</pre>

<h3 id="label-Creating+Identity+Columns">Creating Identity Columns<span><a href="#label-Creating+Identity+Columns">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can use the <code>:identity</code> option when creating columns to mark them as identity columns. Identity columns are tied to a sequence for the default value.  You can still override the default value for the column when inserting:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>){<span class="ruby-constant">Integer</span> <span class="ruby-value">:id</span>, <span class="ruby-value">identity:</span> <span class="ruby-keyword">true</span>}
<span class="ruby-comment"># CREATE TABLE &quot;table&quot; (&quot;id&quot; integer GENERATED BY DEFAULT AS IDENTITY)</span>
</pre>

<p>If you want to disallow using a user provided value when inserting, you can mark the identity column using <code>identity: :always</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>){<span class="ruby-constant">Integer</span> <span class="ruby-value">:id</span>, <span class="ruby-value">identity:</span> <span class="ruby-value">:always</span>}
<span class="ruby-comment"># CREATE TABLE &quot;table&quot; (&quot;id&quot; integer GENERATED ALWAYS AS IDENTITY)</span>
</pre>

<h3 id="label-Creating-2FDropping+Schemas-2C+Languages-2C+Functions-2C+and+Triggers">Creating/Dropping Schemas, Languages, Functions, and Triggers<span><a href="#label-Creating-2FDropping+Schemas-2C+Languages-2C+Functions-2C+and+Triggers">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> has built in support for creating and dropping PostgreSQL schemas, procedural languages, functions, and triggers:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_schema</span>(<span class="ruby-value">:s</span>)
<span class="ruby-comment"># CREATE SCHEMA &quot;s&quot;</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_schema</span>(<span class="ruby-value">:s</span>)
<span class="ruby-comment"># DROP SCHEMA &quot;s&quot;</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_language</span>(<span class="ruby-value">:plperl</span>)
<span class="ruby-comment"># CREATE LANGUAGE plperl</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_language</span>(<span class="ruby-value">:plperl</span>)
<span class="ruby-comment"># DROP LANGUAGE plperl</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_function</span>(<span class="ruby-value">:set_updated_at</span>, <span class="ruby-identifier">&lt;&lt;-SQL</span>, <span class="ruby-value">language:</span> <span class="ruby-value">:plpgsql</span>, <span class="ruby-value">returns:</span> <span class="ruby-value">:trigger</span>)
<span class="ruby-value">  BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
  END;
</span><span class="ruby-identifier">SQL</span>
<span class="ruby-comment"># CREATE FUNCTION set_updated_at() RETURNS trigger LANGUAGE plpgsql AS &#39;</span>
<span class="ruby-comment">#  BEGIN</span>
<span class="ruby-comment">#    NEW.updated_at := CURRENT_TIMESTAMP;</span>
<span class="ruby-comment">#    RETURN NEW;</span>
<span class="ruby-comment">#  END;&#39;</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_function</span>(<span class="ruby-value">:set_updated_at</span>)
<span class="ruby-comment"># DROP FUNCTION set_updated_at()</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_trigger</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">:trg_updated_at</span>, <span class="ruby-value">:set_updated_at</span>, <span class="ruby-value">events:</span> <span class="ruby-value">:update</span>, <span class="ruby-value">each_row:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">when:</span> {<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:new</span>][<span class="ruby-value">:updated_at</span>] <span class="ruby-operator">=&gt;</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:old</span>][<span class="ruby-value">:updated_at</span>]})
<span class="ruby-comment"># CREATE TRIGGER trg_updated_at BEFORE UPDATE ON &quot;table&quot; FOR EACH ROW WHEN (&quot;new&quot;.&quot;updated_at&quot; = &quot;old&quot;.&quot;updated_at&quot;) EXECUTE PROCEDURE set_updated_at()</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_trigger</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">:trg_updated_at</span>)
<span class="ruby-comment"># DROP TRIGGER trg_updated_at ON &quot;table&quot;</span>
</pre>

<p>However, you may want to consider just use <code>Database#run</code> with the necessary SQL code, at least for functions and triggers.</p>

<h3 id="label-Parsing+Check+Constraints">Parsing Check Constraints<span><a href="#label-Parsing+Check+Constraints">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> has support for parsing CHECK constraints on PostgreSQL using <code>Sequel::Database#check_constraints</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:foo</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:i</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:j</span>
  <span class="ruby-identifier">constraint</span>(<span class="ruby-value">:ic</span>, <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:i</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>)
  <span class="ruby-identifier">constraint</span>(<span class="ruby-value">:jc</span>, <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:j</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>)
  <span class="ruby-identifier">constraint</span>(<span class="ruby-value">:ijc</span>, <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:i</span>] <span class="ruby-operator">-</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:j</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">check_constraints</span>(<span class="ruby-value">:foo</span>)
<span class="ruby-comment"># =&gt; {</span>
<span class="ruby-comment">#  :ic=&gt;{:definition=&gt;&quot;CHECK ((i &gt; 2))&quot;, :columns=&gt;[:i]},</span>
<span class="ruby-comment">#  :jc=&gt;{:definition=&gt;&quot;CHECK ((j &gt; 2))&quot;, :columns=&gt;[:j]},</span>
<span class="ruby-comment">#  :ijc=&gt;{:definition=&gt;&quot;CHECK (((i - j) &gt; 2))&quot;, :columns=&gt;[:i, :j]}</span>
<span class="ruby-comment"># }</span>
</pre>

<h3 id="label-Parsing+Foreign+Key+Constraints+Referencing+A+Given+Table">Parsing Foreign Key Constraints Referencing A Given Table<span><a href="#label-Parsing+Foreign+Key+Constraints+Referencing+A+Given+Table">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> has support for parsing FOREIGN KEY constraints that reference a given table, using the <code>:reverse</code> option to <code>foreign_key_list</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table!</span>(<span class="ruby-value">:a</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:i</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:j</span>
  <span class="ruby-identifier">foreign_key</span> <span class="ruby-value">:a_id</span>, <span class="ruby-value">:a</span>, <span class="ruby-value">foreign_key_constraint_name:</span> <span class="ruby-value">:a_a</span>
  <span class="ruby-identifier">unique</span> [<span class="ruby-value">:i</span>, <span class="ruby-value">:j</span>]
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table!</span>(<span class="ruby-value">:b</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">foreign_key</span> <span class="ruby-value">:a_id</span>, <span class="ruby-value">:a</span>, <span class="ruby-value">foreign_key_constraint_name:</span> <span class="ruby-value">:a_a</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:c</span>
  <span class="ruby-constant">Integer</span> <span class="ruby-value">:d</span>
  <span class="ruby-identifier">foreign_key</span> [<span class="ruby-value">:c</span>, <span class="ruby-value">:d</span>], <span class="ruby-value">:a</span>, <span class="ruby-value">key:</span> [<span class="ruby-value">:j</span>, <span class="ruby-value">:i</span>], <span class="ruby-value">name:</span> <span class="ruby-value">:a_c_d</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">foreign_key_list</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">reverse:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># =&gt; [</span>
<span class="ruby-comment">#  {:name=&gt;:a_a, :columns=&gt;[:a_id], :key=&gt;[:id], :on_update=&gt;:no_action, :on_delete=&gt;:no_action, :deferrable=&gt;false, :table=&gt;:a, :schema=&gt;:public},</span>
<span class="ruby-comment">#  {:name=&gt;:a_a, :columns=&gt;[:a_id], :key=&gt;[:id], :on_update=&gt;:no_action, :on_delete=&gt;:no_action, :deferrable=&gt;false, :table=&gt;:b, :schema=&gt;:public},</span>
<span class="ruby-comment">#  {:name=&gt;:a_c_d, :columns=&gt;[:c, :d], :key=&gt;[:j, :i], :on_update=&gt;:no_action, :on_delete=&gt;:no_action, :deferrable=&gt;false, :table=&gt;:b, :schema=&gt;:public}</span>
<span class="ruby-comment"># ]</span>
</pre>

<h2 id="label-PostgreSQL-specific+DML+Support">PostgreSQL-specific DML Support<span><a href="#label-PostgreSQL-specific+DML+Support">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Returning+Rows+From+Insert-2C+Update-2C+and+Delete+Statements">Returning Rows From Insert, Update, and Delete Statements<span><a href="#label-Returning+Rows+From+Insert-2C+Update-2C+and+Delete+Statements">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> supports the ability to return rows from insert, update, and delete statements, via <code>Dataset#returning</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">returning</span>.<span class="ruby-identifier">insert</span>
<span class="ruby-comment"># INSERT INTO &quot;table&quot; DEFAULT VALUES RETURNING *</span>

<span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">returning</span>(<span class="ruby-value">:id</span>).<span class="ruby-identifier">delete</span>
<span class="ruby-comment"># DELETE FROM &quot;table&quot; RETURNING &quot;id&quot;</span>

<span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">returning</span>(<span class="ruby-value">:id</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">*</span>(<span class="ruby-value">:id</span>, <span class="ruby-value">:id</span>).<span class="ruby-identifier">as</span>(<span class="ruby-value">:idsq</span>)).<span class="ruby-identifier">update</span>(<span class="ruby-value">id:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># UPDATE &quot;table&quot; SET &quot;id&quot; = 2 RETURNING &quot;id&quot;, (&quot;id&quot; * &quot;id&quot;) AS &quot;idsq&quot;</span>
</pre>

<p>When returning is used, instead of returning the number of rows affected (for updated/delete) or the serial primary key value (for insert), it will return an array of hashes with the returning results.</p>

<h3 id="label-VALUES+Support">VALUES Support<span><a href="#label-VALUES+Support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> offers support for the <code>VALUES</code> statement using <code>Database#values</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">values</span>([[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">2</span>,<span class="ruby-value">3</span>],[<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]])
<span class="ruby-comment"># VALUES (1, 2), (2, 3), (3, 4)</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">values</span>([[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">2</span>,<span class="ruby-value">3</span>],[<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]]).<span class="ruby-identifier">order</span>(<span class="ruby-value">2</span>, <span class="ruby-value">1</span>)
<span class="ruby-comment"># VALUES (1, 2), (2, 3), (3, 4) ORDER BY 2, 1</span>

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">values</span>([[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">2</span>,<span class="ruby-value">3</span>],[<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]]).<span class="ruby-identifier">order</span>(<span class="ruby-value">2</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)
<span class="ruby-comment"># VALUES (1, 2), (2, 3), (3, 4) ORDER BY 2, 1 LIMIT 1 OFFSET 2</span>
</pre>

<h3 id="label-INSERT+ON+CONFLICT+Support">INSERT ON CONFLICT Support<span><a href="#label-INSERT+ON+CONFLICT+Support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Starting with PostgreSQL 9.5, you can do an upsert or ignore unique or exclusion constraint violations when inserting using <code>Dataset#insert_conflict</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_conflict</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT DO NOTHING</span>
</pre>

<p>For compatibility with Sequel’s MySQL support, you can also use <code>insert_ignore</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_ignore</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT DO NOTHING</span>
</pre>

<p>You can pass a specific constraint name using <code>:constraint</code>, to only ignore a specific constraint violation:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_conflict</span>(<span class="ruby-value">constraint:</span> <span class="ruby-value">:table_a_uidx</span>).<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT ON CONSTRAINT table_a_uidx DO NOTHING</span>
</pre>

<p>If the unique or exclusion constraint covers the whole table (e.g. it isn’t a partial unique index), then you can just specify the column using the <code>:target</code> option:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_conflict</span>(<span class="ruby-value">target:</span> <span class="ruby-value">:a</span>).<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT (a) DO NOTHING</span>
</pre>

<p>If you want to update the existing row instead of ignoring the constraint violation, you can pass an <code>:update</code> option with a hash of values to update.  You must pass either the <code>:target</code> or <code>:constraint</code> options when passing the <code>:update</code> option:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_conflict</span>(<span class="ruby-value">target:</span> <span class="ruby-value">:a</span>, <span class="ruby-value">update:</span> {<span class="ruby-value">b:</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:excluded</span>][<span class="ruby-value">:b</span>]}).<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT (a) DO UPDATE SET b = excluded.b</span>
</pre>

<p>If you want to update existing rows but using the current value of the column, you can build the desired calculation using <code>Sequel[]</code></p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>]
  .<span class="ruby-identifier">insert_conflict</span>(
    <span class="ruby-value">target:</span> <span class="ruby-value">:a</span>,
    <span class="ruby-value">update:</span> {<span class="ruby-value">b:</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:excluded</span>][<span class="ruby-value">:b</span>] <span class="ruby-operator">+</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:table</span>][<span class="ruby-value">:a</span>]}
  )
  .<span class="ruby-identifier">import</span>([<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>], [ [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] ])
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT (a) DO UPDATE SET b = (excluded.b + table.a)</span>
</pre>

<p>Additionally, if you only want to do the update in certain cases, you can specify an <code>:update_where</code> option, which will be used as a filter.  If the row doesn’t match the conditions, the constraint violation will be ignored, but the row will not be updated:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert_conflict</span>(<span class="ruby-identifier">constraint</span><span class="ruby-operator">::</span><span class="ruby-identifier">table_a_uidx</span>,
  <span class="ruby-value">update:</span> {<span class="ruby-value">b:</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:excluded</span>][<span class="ruby-value">:b</span>]},
  <span class="ruby-value">update_where:</span> {<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:table</span>][<span class="ruby-value">:status_id</span>]<span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>}).<span class="ruby-identifier">insert</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> <span class="ruby-value">2</span>)
<span class="ruby-comment"># INSERT INTO TABLE (a, b) VALUES (1, 2)</span>
<span class="ruby-comment"># ON CONFLICT ON CONSTRAINT table_a_uidx</span>
<span class="ruby-comment"># DO UPDATE SET b = excluded.b WHERE (table.status_id = 1)</span>
</pre>

<h3 id="label-INSERT+OVERRIDING+SYSTEM-7CUSER+VALUE+Support">INSERT OVERRIDING SYSTEM|USER VALUE Support<span><a href="#label-INSERT+OVERRIDING+SYSTEM-7CUSER+VALUE+Support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>PostgreSQL 10+ supports identity columns, which are designed to replace the serial columns previously used for autoincrementing primary keys.  You can use Dataset#overriding_system_value and Dataset#overriding_user_value to use this new syntax:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>){<span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>}
<span class="ruby-comment"># Ignore the given value for id, using the identity&#39;s sequence value.</span>
<span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">overriding_user_value</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">id:</span> <span class="ruby-value">1</span>)

<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:table</span>){<span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>, <span class="ruby-value">identity:</span> <span class="ruby-value">:always</span>}
<span class="ruby-comment"># Force the use of the given value for id, because otherwise the insert will</span>
<span class="ruby-comment"># raise an error, since GENERATED ALWAYS was used when creating the column.</span>
<span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">overriding_system_value</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">id:</span> <span class="ruby-value">1</span>)
</pre>

<h3 id="label-Distinct+On+Specific+Columns">Distinct On Specific Columns<span><a href="#label-Distinct+On+Specific+Columns">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> allows passing columns to <code>Dataset#distinct</code>, which will make the dataset return rows that are distinct on just those columns:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">distinct</span>(<span class="ruby-value">:id</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT DISTINCT ON (&quot;id&quot;) * FROM &quot;table&quot;</span>
</pre>

<h3 id="label-JOIN+USING+table+alias">JOIN USING table alias<span><a href="#label-JOIN+USING+table+alias">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> allows passing an SQL::AliasedExpression to join table methods to use a USING join with a table alias for the USING columns:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:t1</span>].<span class="ruby-identifier">join</span>(<span class="ruby-value">:t2</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>([<span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>], <span class="ruby-value">:alias</span>))
<span class="ruby-comment"># SELECT * FROM &quot;t1&quot; INNER JOIN &quot;t2&quot; USING (&quot;c1&quot;, &quot;c2&quot;) AS &quot;alias&quot;</span>
</pre>

<h3 id="label-Calling+PostgreSQL+11-2B+Procedures+postgres+only">Calling PostgreSQL 11+ Procedures <code>postgres only</code><span><a href="#label-Calling+PostgreSQL+11-2B+Procedures+postgres+only">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>PostgreSQL 11+ added support for procedures, which are different from the user defined functions that PostgreSQL has historically supported.  These procedures are called via a special <code>CALL</code> syntax, and <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports them via <code>Database#call_procedure</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">call_procedure</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">1</span>, <span class="ruby-string">&quot;bar&quot;</span>)
<span class="ruby-comment"># CALL foo(1, &#39;bar&#39;)</span>
</pre>

<p><code>Database#call_procedure</code> will return a hash of return values if the procedure returns a result, or <code>nil</code> if the procedure does not return a result.</p>

<h3 id="label-Using+a+Cursor+to+Process+Large+Datasets+postgres+only">Using a Cursor to Process Large Datasets <code>postgres only</code><span><a href="#label-Using+a+Cursor+to+Process+Large+Datasets+postgres+only">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The postgres adapter offers a <code>Dataset#use_cursor</code> method to process large result sets without keeping all rows in memory:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">use_cursor</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }
<span class="ruby-comment"># BEGIN;</span>
<span class="ruby-comment"># DECLARE sequel_cursor NO SCROLL CURSOR WITHOUT HOLD FOR SELECT * FROM &quot;table&quot;;</span>
<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>
<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>
<span class="ruby-comment"># ...</span>
<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>
<span class="ruby-comment"># CLOSE sequel_cursor</span>
<span class="ruby-comment"># COMMIT</span>
</pre>

<p>This support is used by default when using <code>Dataset#paged_each</code>.</p>

<p>Using cursors, it is possible to update individual rows of a large dataset easily using the <code>rows_per_fetch: 1</code> option in conjunction with <code>Dataset#where_current_of</code>.  This is useful if the logic needed to update the rows exists in the application and not in the database:</p>

<pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">use_cursor</span>(<span class="ruby-value">rows_per_fetch:</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where_current_of</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">col:</span> <span class="ruby-identifier">new_col_value</span>(<span class="ruby-identifier">row</span>))
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Truncate+Modifiers">Truncate Modifiers<span><a href="#label-Truncate+Modifiers">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> supports PostgreSQL-specific truncate options:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">truncate</span>(<span class="ruby-value">cascade:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">only:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">restart:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># TRUNCATE TABLE ONLY &quot;table&quot; RESTART IDENTITY CASCADE</span>
</pre>

<h3 id="label-COPY+Support+postgres-2Fpg+and+jdbc-2Fpostgres+only+">COPY Support <code>postgres/pg and jdbc/postgres only</code> <span><a href="#label-COPY+Support+postgres-2Fpg+and+jdbc-2Fpostgres+only+">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>PostgreSQL’s COPY feature is pretty much the fastest way to get data in or out of the database. <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports getting data out of the database via <code>Database#copy_table</code>, either for a specific table or for an arbitrary dataset:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">format:</span> <span class="ruby-value">:csv</span>)
<span class="ruby-comment"># COPY &quot;table&quot; TO STDOUT (FORMAT csv)</span>
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(<span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>], <span class="ruby-value">format:</span> <span class="ruby-value">:csv</span>)
<span class="ruby-comment"># COPY (SELECT * FROM &quot;table&quot;) TO STDOUT (FORMAT csv)</span>
</pre>

<p>It supports putting data into the database via <code>Database#copy_into</code>:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_into</span>(<span class="ruby-value">:table</span>, <span class="ruby-value">format:</span> <span class="ruby-value">:csv</span>, <span class="ruby-value">columns:</span> [<span class="ruby-value">:column1</span>, <span class="ruby-value">:column2</span>], <span class="ruby-value">data:</span> <span class="ruby-string">&quot;1,2\n2,3\n&quot;</span>)
<span class="ruby-comment"># COPY &quot;table&quot;(&quot;column1&quot;, &quot;column2&quot;) FROM STDIN (FORMAT csv)</span>
</pre>

<h3 id="label-Anonymous+Function+Execution">Anonymous Function Execution<span><a href="#label-Anonymous+Function+Execution">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can execute anonymous functions using a database procedural language via <code>Database#do</code> (the plpgsql language is the default):</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">do</span> <span class="ruby-identifier">&lt;&lt;-SQL</span>
<span class="ruby-value">  DECLARE r record;
  BEGIN
   FOR r IN SELECT table_schema, table_name FROM information_schema.tables
     WHERE table_type = &#39;VIEW&#39; AND table_schema = &#39;public&#39;
   LOOP
     EXECUTE &#39;GRANT ALL ON &#39; || quote_ident(r.table_schema) || &#39;.&#39; || quote_ident(r.table_name) || &#39; TO webuser&#39;;
   END LOOP;
  END;
</span><span class="ruby-identifier">SQL</span>
</pre>

<h3 id="label-Listening+On+and+Notifying+Channels">Listening On and Notifying Channels<span><a href="#label-Listening+On+and+Notifying+Channels">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can use <code>Database#notify</code> to send notification to channels:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">notify</span>(<span class="ruby-value">:channel</span>)
<span class="ruby-comment"># NOTIFY &quot;channel&quot;</span>
</pre>

<p><code>postgres/pg only</code> You can listen on channels via <code>Database#listen</code>.  Note that this blocks until the listening thread is notified:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">listen</span>(<span class="ruby-value">:channel</span>)
<span class="ruby-comment"># LISTEN &quot;channel&quot;</span>
<span class="ruby-comment"># after notification received:</span>
<span class="ruby-comment"># UNLISTEN *</span>
</pre>

<p>Note that <code>listen</code> by default only listens for a single notification.  If you want to loop and process notifications:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">listen</span>(<span class="ruby-value">:channel</span>, <span class="ruby-value">loop:</span> <span class="ruby-keyword">true</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">channel</span>}
</pre>

<p>The <code>pg_static_cache_updater</code> extension uses this support to automatically update the caches for models using the <code>static_cache</code> plugin.  Look at the documentation of that plugin for details.</p>

<h3 id="label-Locking+Tables">Locking Tables<span><a href="#label-Locking+Tables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> makes it easy to lock tables, though it is generally better to let the database handle locking:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">lock</span>(<span class="ruby-string">&#39;EXCLUSIVE&#39;</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">insert</span>(<span class="ruby-value">id:</span> <span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">:id</span>)<span class="ruby-value">+1</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># BEGIN;</span>
<span class="ruby-comment"># LOCK TABLE &quot;table&quot; IN EXCLUSIVE MODE;</span>
<span class="ruby-comment"># SELECT max(&quot;id&quot;) FROM &quot;table&quot; LIMIT 1;</span>
<span class="ruby-comment"># INSERT INTO &quot;table&quot; (&quot;id&quot;) VALUES (2) RETURNING NULL;</span>
<span class="ruby-comment"># COMMIT;</span>
</pre>

<h2 id="label-Extended+Error+Info+-28postgres-2Fpg+only-29">Extended Error Info (<code>postgres/pg only</code>)<span><a href="#label-Extended+Error+Info+-28postgres-2Fpg+only-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you run a query that raises a Sequel::DatabaseError, you can pass the exception object to <code>Database#error_info</code>, and that will return a hash with metadata regarding the error, such as the related table and column or constraint.</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:test1</span>){<span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>}
<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-value">:test2</span>){<span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>; <span class="ruby-identifier">foreign_key</span> <span class="ruby-value">:test1_id</span>, <span class="ruby-value">:test1</span>}
<span class="ruby-constant">DB</span>[<span class="ruby-value">:test2</span>].<span class="ruby-identifier">insert</span>(<span class="ruby-value">test1_id:</span> <span class="ruby-value">1</span>) <span class="ruby-keyword">rescue</span> <span class="ruby-constant">DB</span>.<span class="ruby-identifier">error_info</span>(<span class="ruby-identifier">$!</span>)
<span class="ruby-comment"># =&gt; {</span>
<span class="ruby-comment">#  :schema=&gt;&quot;public&quot;,</span>
<span class="ruby-comment">#  :table=&gt;&quot;test2&quot;,</span>
<span class="ruby-comment">#  :column=&gt;nil,</span>
<span class="ruby-comment">#  :constraint=&gt;&quot;test2_test1_id_fkey&quot;,</span>
<span class="ruby-comment">#  :type=&gt;nil,</span>
<span class="ruby-comment">#  :severity=&gt;&quot;ERROR&quot;,</span>
<span class="ruby-comment">#  :sql_state=&gt;&quot;23503&quot;,</span>
<span class="ruby-comment">#  :message_primary=&gt;&quot;insert or update on table \&quot;test2\&quot; violates foreign key constraint \&quot;test2_test1_id_fkey\&quot;&quot;,</span>
<span class="ruby-comment">#  :message_detail=&gt;&quot;Key (test1_id)=(1) is not present in table \&quot;test1\&quot;.&quot;</span>
<span class="ruby-comment">#  :message_hint=&gt;nil,</span>
<span class="ruby-comment">#  :statement_position=&gt;nil,</span>
<span class="ruby-comment">#  :internal_position=&gt;nil,</span>
<span class="ruby-comment">#  :internal_query=&gt;nil,</span>
<span class="ruby-comment">#  :source_file=&gt;&quot;ri_triggers.c&quot;,</span>
<span class="ruby-comment">#  :source_line=&gt;&quot;3321&quot;,</span>
<span class="ruby-comment">#  :source_function=&gt;&quot;ri_ReportViolation&quot;</span>
<span class="ruby-comment"># }</span>
</pre>

<h2 id="label-sequel_pg+-28postgres-2Fpg+only-29">sequel_pg (<code>postgres/pg only</code>)<span><a href="#label-sequel_pg+-28postgres-2Fpg+only-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When the postgres adapter is used with the pg driver, <a href="../../classes/Sequel.html"><code>Sequel</code></a> automatically checks for sequel_pg, and loads it if it is available.  sequel_pg is a C extension that optimizes the fetching of rows, generally resulting in a ~2x speedup.  It is highly recommended to install sequel_pg if you are using the postgres adapter with pg.</p>

<p>sequel_pg has additional optimizations when using the Dataset <code>map</code>, <code>as_hash</code>, <code>to_hash_groups</code>, <code>select_hash</code>, <code>select_hash_groups</code>, <code>select_map</code>, and <code>select_order_map</code> methods, which avoids creating intermediate hashes and can add further speedups.</p>

<p>In addition to optimization, sequel_pg also adds streaming support if used on PostgreSQL 9.2+. Streaming support is similar to using a cursor, but it is faster and more transparent.</p>

<p>You can enable the streaming support:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span>(<span class="ruby-value">:pg_streaming</span>)
</pre>

<p>Then you can stream individual datasets:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">stream</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }
</pre>

<p>Or stream all datasets by default:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">stream_all_queries</span> = <span class="ruby-keyword">true</span>
</pre>

<p>When streaming is enabled, <code>Dataset#paged_each</code> will use streaming to implement paging.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
