<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>core_extensions.rdoc</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>core_extensions.rdoc
</h1>
<div class='paths'>
doc/core_extensions.rdoc
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Sequel-27s+Core+Extensions">Sequel’s Core Extensions<span><a href="#label-Sequel-27s+Core+Extensions">&para;</a> <a href="#top">&uarr;</a></span></h1>

<h2 id="label-Background">Background<span><a href="#label-Background">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Historically, <a href="../../classes/Sequel.html"><code>Sequel</code></a> added methods to many of the core classes, and usage of those methods was the primary and recommended way to use <a href="../../classes/Sequel.html"><code>Sequel</code></a>.  For example:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">select</span>(<span class="ruby-value">:column</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-constant">Integer</span>)). <span class="ruby-comment"># Symbol#cast</span>
  <span class="ruby-identifier">where</span>(<span class="ruby-value">:column</span>.<span class="ruby-identifier">like</span>(<span class="ruby-string">&#39;A%&#39;</span>)).              <span class="ruby-comment"># Symbol#like</span>
  <span class="ruby-identifier">order</span>({<span class="ruby-value">1</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>, <span class="ruby-value">:a</span>))               <span class="ruby-comment"># Hash#case</span>
</pre>

<p>While <a href="../../classes/Sequel.html"><code>Sequel</code></a> never overrode any methods defined by ruby, it is possible that other libraries could define the same methods that <a href="../../classes/Sequel.html"><code>Sequel</code></a> defines, which could cause problems.  Also, some rubyists do not like using libraries that add methods to the core classes.</p>

<p>Alternatives for the core extension methods were added to <a href="../../classes/Sequel.html"><code>Sequel</code></a>, so the query above could be written as:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">select</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:column</span>, <span class="ruby-constant">Integer</span>)).
  <span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-value">:column</span>, <span class="ruby-string">&#39;A%&#39;</span>)).
  <span class="ruby-identifier">order</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({<span class="ruby-value">1</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>}, <span class="ruby-value">0</span>, <span class="ruby-value">:a</span>))
</pre>

<p>or with virtual rows:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:table</span>].<span class="ruby-identifier">select</span>{<span class="ruby-identifier">column</span>.<span class="ruby-identifier">as</span>(<span class="ruby-constant">Integer</span>)}.
  <span class="ruby-identifier">where</span>{<span class="ruby-identifier">column</span>.<span class="ruby-identifier">like</span>(<span class="ruby-string">&#39;A%&#39;</span>)}.
  <span class="ruby-identifier">order</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({<span class="ruby-value">1</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>}, <span class="ruby-value">0</span>, <span class="ruby-value">:a</span>))
</pre>

<p>Almost all of the core extension methods have a replacement on the <a href="../../classes/Sequel.html"><code>Sequel</code></a> module.  So it is now up to the user which style to use.  Using the methods on the <a href="../../classes/Sequel.html"><code>Sequel</code></a> module results in slightly more verbose code, but allows the code to work without modifications to the core classes.</p>

<h2 id="label-Issues">Issues<span><a href="#label-Issues">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There is no recommendation on whether the <a href="core_extensions_rdoc.html">core_extensions</a> should be used or not.  It is very rare that any of the methods added by <a href="core_extensions_rdoc.html">core_extensions</a> actually causes a problem, but some of them can make it more difficult to find other problems.  For example, if you type:</p>

<pre class="ruby"><span class="ruby-identifier">do_something</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">other_value</span>
</pre>

<p>while meaning to type:</p>

<pre class="ruby"><span class="ruby-identifier">do_something</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">other_value</span>
</pre>

<p>and value is a Symbol, instead of a NoMethodError being raised because Symbol#| is not implemented by default, <code>value | other_value</code> will return a <a href="../../classes/Sequel.html"><code>Sequel</code></a> expression object, which if will evaluate as true, and do_something will be called.</p>

<h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>All of Sequel’s extensions to the core classes are stored in Sequel’s <a href="core_extensions_rdoc.html">core_extensions</a> extension, which you can load via:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:core_extensions</span>
</pre>

<h2 id="label-No+Internal+Dependency">No Internal Dependency<span><a href="#label-No+Internal+Dependency">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> has no internal dependency on the core extensions.  This includes Sequel’s core, <a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a>, and all plugins and extensions that ship with <a href="../../classes/Sequel.html"><code>Sequel</code></a>.  However, it is possible that external plugins and extensions will depend on the core extensions.  Such plugins and extensions should be updated so that they no longer depend on the core extensions.</p>

<h2 id="label-Refinements">Refinements<span><a href="#label-Refinements">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Most of the these extensions can be added on a per-file basis using refinements (if you are using Ruby 2.0+).  To use refinements, first load them:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:core_refinements</span>
</pre>

<p>Then for each file where you want to use the refinements:</p>

<pre class="ruby"><span class="ruby-identifier">using</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">CoreRefinements</span>
</pre>

<h2 id="label-Core+Extension+Methods">Core Extension Methods<span><a href="#label-Core+Extension+Methods">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This section will briefly describe all of the methods added to the core classes, and what the alternative method is that doesn’t require the core extensions.</p>

<h3 id="label-Symbol+-26+String">Symbol &amp; String<span><a href="#label-Symbol+-26+String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-as">as<span><a href="#label-as">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#as and String#as return <a href="../../classes/Sequel.html"><code>Sequel</code></a> aliased expressions using the provided alias:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">as</span>(<span class="ruby-value">:b</span>)  <span class="ruby-comment"># SQL: a AS b</span>
<span class="ruby-string">&#39;a&#39;</span>.<span class="ruby-identifier">as</span>(<span class="ruby-value">:b</span>) <span class="ruby-comment"># SQL: &#39;a&#39; AS b</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">as</span>(<span class="ruby-value">:b</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
</pre>

<h4 id="label-cast">cast<span><a href="#label-cast">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#cast and String#cast return <a href="../../classes/Sequel.html"><code>Sequel</code></a> cast expressions for typecasting in the database:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-constant">Integer</span>)  <span class="ruby-comment"># SQL: CAST(a AS integer)</span>
<span class="ruby-string">&#39;a&#39;</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-constant">Integer</span>) <span class="ruby-comment"># SQL: CAST(&#39;a&#39; AS integer)</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">cast</span>(<span class="ruby-constant">Integer</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:a</span>, <span class="ruby-constant">Integer</span>)
</pre>

<h4 id="label-cast_numeric">cast_numeric<span><a href="#label-cast_numeric">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#cast_numeric and String#cast_numeric return <a href="../../classes/Sequel.html"><code>Sequel</code></a> cast expressions for typecasting in the database, defaulting to integers, where the returned expression is treated as an numeric value:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">cast_numeric</span>         <span class="ruby-comment"># SQL: CAST(a AS integer)</span>
<span class="ruby-string">&#39;a&#39;</span>.<span class="ruby-identifier">cast_numeric</span>(<span class="ruby-constant">Float</span>) <span class="ruby-comment"># SQL: CAST(&#39;a&#39; AS double precision)</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">cast_numeric</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast_numeric</span>(<span class="ruby-value">:a</span>)
</pre>

<h4 id="label-cast_string">cast_string<span><a href="#label-cast_string">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#cast_string and String#cast_string return <a href="../../classes/Sequel.html"><code>Sequel</code></a> cast expressions for typecasting in the database, defaulting to strings, where the returned expression is treated as a string value:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">cast_string</span>         <span class="ruby-comment"># SQL: CAST(a AS varchar(255))</span>
<span class="ruby-string">&#39;a&#39;</span>.<span class="ruby-identifier">cast_string</span>(<span class="ruby-value">:text</span>) <span class="ruby-comment"># SQL: CAST(&#39;a&#39; AS text)</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">cast_string</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast_string</span>(<span class="ruby-value">:a</span>)
</pre>

<h3 id="label-Symbol">Symbol<span><a href="#label-Symbol">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-identifier">identifier<span><a href="#label-identifier">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#identifier wraps the symbol in an <a href="../../classes/Sequel.html"><code>Sequel</code></a> identifier object.  If symbol splitting is enabled (no longer the default), it also makes sure the symbol will not be split.  If symbol splitting is disabled (the default), there is little reason to use this).</p>

<pre class="ruby"><span class="ruby-value">:column</span>.<span class="ruby-identifier">identifier</span> <span class="ruby-comment"># SQL: column</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:column</span>]
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">identifier</span>(<span class="ruby-value">:column</span>)
</pre>

<h4 id="label-asc">asc<span><a href="#label-asc">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#asc is used to define an ascending order on a column.  It exists mostly for consistency with desc, since ascending is the default order:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">asc</span> <span class="ruby-comment"># SQL: a ASC</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">asc</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">asc</span>(<span class="ruby-value">:a</span>)
</pre>

<h4 id="label-desc">desc<span><a href="#label-desc">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#desc is used to defined a descending order on a column.  The returned value is usually passed to one of the dataset order methods.</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">desc</span> <span class="ruby-comment"># SQL: a DESC</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">desc</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">desc</span>(<span class="ruby-value">:a</span>)
</pre>

<h4 id="label-2B-2C+--2C+-2A-2C+-2F">+, -, *, /<span><a href="#label-2B-2C+--2C+-2A-2C+-2F">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The standard mathematical operators are defined on Symbol, and return a <a href="../../classes/Sequel.html"><code>Sequel</code></a> numeric expression object representing the operation:</p>

<pre class="ruby"><span class="ruby-value">:a</span> <span class="ruby-operator">+</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a + b</span>
<span class="ruby-value">:a</span> <span class="ruby-operator">-</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a - b</span>
<span class="ruby-value">:a</span> <span class="ruby-operator">*</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a * b</span>
<span class="ruby-value">:a</span> <span class="ruby-operator">/</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a / b</span>
<span class="ruby-value">:a</span> <span class="ruby-operator">**</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: power(a, b)</span>
</pre>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> also supports ruby’s coercion protocols on symbols (note that this does not work when using refinements):</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">+</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: 1 + b</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>] <span class="ruby-operator">+</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>] <span class="ruby-operator">-</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>] <span class="ruby-operator">*</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>] <span class="ruby-operator">/</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>] <span class="ruby-operator">**</span> <span class="ruby-value">:b</span>

<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">+</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">-</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">*</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">/</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">**</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>)
</pre>

<h4 id="label-2A">*<span><a href="#label-2A">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The * operator is overloaded on Symbol such that if it is called with no arguments, it represents a selection of all columns in the table:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">*</span> <span class="ruby-comment"># SQL: a.*</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">*</span>
</pre>

<h4 id="label-qualify">qualify<span><a href="#label-qualify">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#qualify qualifies the identifier (e.g. a column) with a another identifier (e.g. a table):</p>

<pre class="ruby"><span class="ruby-value">:column</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-value">:table</span>) <span class="ruby-comment"># SQL: table.column</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:table</span>][<span class="ruby-value">:column</span>]
</pre>

<p>Note the reversed order of the arguments.  For the Symbol#qualify method, the argument is the qualifier, while for <a href="">Sequel[]</a>, the first [] is the qualifier, and the second [] is the identifier.</p>

<h4 id="label-like">like<span><a href="#label-like">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#like returns a case sensitive LIKE expression between the identifier and the given argument:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">like</span>(<span class="ruby-string">&#39;b%&#39;</span>) <span class="ruby-comment"># SQL: a LIKE &#39;b%&#39; ESCAPE &#39;\&#39;</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">like</span>(<span class="ruby-string">&#39;b%&#39;</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-value">:a</span>, <span class="ruby-string">&#39;b%&#39;</span>)
</pre>

<h4 id="label-ilike">ilike<span><a href="#label-ilike">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#ilike returns a case insensitive LIKE expression between the identifier and the given argument:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">ilike</span>(<span class="ruby-string">&#39;b%&#39;</span>) <span class="ruby-comment"># SQL: a ILIKE &#39;b%&#39; ESCAPE &#39;\&#39;</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">ilike</span>(<span class="ruby-string">&#39;b%&#39;</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">ilike</span>(<span class="ruby-value">:a</span>, <span class="ruby-string">&#39;b%&#39;</span>)
</pre>

<h4 id="label-sql_subscript">sql_subscript<span><a href="#label-sql_subscript">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#sql_subscript returns a <a href="../../classes/Sequel.html"><code>Sequel</code></a> expression representing an SQL array access:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">sql_subscript</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># SQL: a[1]</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">sql_subscript</span>(<span class="ruby-value">1</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">subscript</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">1</span>)
</pre>

<h4 id="label-extract">extract<span><a href="#label-extract">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#extract does a datetime part extraction from the receiver:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">extract</span>(<span class="ruby-value">:year</span>) <span class="ruby-comment"># SQL: extract(year FROM a)</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">extract</span>(<span class="ruby-value">:year</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extract</span>(<span class="ruby-value">:year</span>, <span class="ruby-value">:a</span>)
</pre>

<h4 id="label-sql_boolean-2C+sql_number-2C+sql_string">sql_boolean, sql_number, sql_string<span><a href="#label-sql_boolean-2C+sql_number-2C+sql_string">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>These Symbol methods are used to force the treating of the object as a specific SQL type, instead of as a general SQL type.  For example:</p>

<pre class="ruby"><span class="ruby-value">:a</span>.<span class="ruby-identifier">sql_boolean</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>  <span class="ruby-comment"># NoMethodError</span>
<span class="ruby-value">:a</span>.<span class="ruby-identifier">sql_number</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span>  <span class="ruby-comment"># SQL: a &lt;&lt; 1</span>
<span class="ruby-value">:a</span>.<span class="ruby-identifier">sql_string</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;a&#39;</span> <span class="ruby-comment"># SQL: a || &#39;a&#39;</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">sql_boolean</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">sql_number</span>
<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">sql_string</span>
</pre>

<h4 id="label-sql_function">sql_function<span><a href="#label-sql_function">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Symbol#sql_function returns an SQL function call expression object:</p>

<pre class="ruby"><span class="ruby-value">:now</span>.<span class="ruby-identifier">sql_function</span> <span class="ruby-comment"># SQL: now()</span>
<span class="ruby-value">:sum</span>.<span class="ruby-identifier">sql_function</span>(<span class="ruby-value">:a</span>) <span class="ruby-comment"># SQL: sum(a)</span>
<span class="ruby-value">:concat</span>.<span class="ruby-identifier">sql_function</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>) <span class="ruby-comment"># SQL: concat(a, b)</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">:sum</span>].<span class="ruby-identifier">function</span>(<span class="ruby-value">:a</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">:sum</span>, <span class="ruby-value">:a</span>)
</pre>

<h3 id="label-String">String<span><a href="#label-String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-lit">lit<span><a href="#label-lit">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>String#lit creates a literal string, using placeholders if any arguments are given.  Literal strings are not escaped, they are treated as SQL code, not as an SQL string:</p>

<pre class="ruby"><span class="ruby-string">&#39;a&#39;</span>.<span class="ruby-identifier">lit</span>          <span class="ruby-comment"># SQL: a</span>
<span class="ruby-string">&#39;&quot;a&quot; = ?&#39;</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># SQL: &quot;a&quot; = 1</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;a&#39;</span>)
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;a = ?&#39;</span>, <span class="ruby-value">1</span>)
</pre>

<h4 id="label-to_sequel_blob">to_sequel_blob<span><a href="#label-to_sequel_blob">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>String#to_sequel_blob returns the string wrapper in <a href="../../classes/Sequel.html"><code>Sequel</code></a> blob object.  Often blobs need to be handled differently than regular strings by the database adapters.</p>

<pre class="ruby"><span class="ruby-string">&quot;a\0&quot;</span>.<span class="ruby-identifier">to_sequel_blob</span> <span class="ruby-comment"># SQL: X&#39;6100&#39;</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">blob</span>(<span class="ruby-string">&quot;a\0&quot;</span>)
</pre>

<h3 id="label-Hash-2C+Array-2C+-26+Symbol">Hash, Array, &amp; Symbol<span><a href="#label-Hash-2C+Array-2C+-26+Symbol">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-~">~<span><a href="#label-~">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#~, Hash#~, and Symbol#~ treat the receiver as a conditions specifier, not matching all of the conditions:</p>

<pre class="ruby"><span class="ruby-operator">~</span>{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]}       <span class="ruby-comment"># SQL: a != 1 OR b NOT IN (2, 3)</span>
<span class="ruby-operator">~</span>[[<span class="ruby-value">:a</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">:b</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]]] <span class="ruby-comment"># SQL: a != 1 OR b NOT IN (1, 2)</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-operator">~</span><span class="ruby-constant">Sequel</span>[<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]]
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">~</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>])
</pre>

<h3 id="label-Hash+-26+Array">Hash &amp; Array<span><a href="#label-Hash+-26+Array">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-case">case<span><a href="#label-case">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#case and Hash#case return an SQL CASE expression, where the keys are conditions and the values are results:</p>

<pre class="ruby">{{<span class="ruby-value">a:</span> [<span class="ruby-value">2</span>,<span class="ruby-value">3</span>]} <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># SQL: CASE WHEN a IN (2, 3) THEN 1 ELSE 0 END</span>
[[{<span class="ruby-value">a:</span> [<span class="ruby-value">2</span>,<span class="ruby-value">3</span>]}, <span class="ruby-value">1</span>]].<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># SQL: CASE WHEN a IN (2, 3) THEN 1 ELSE 0 END</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({{<span class="ruby-value">a:</span> [<span class="ruby-value">2</span>,<span class="ruby-value">3</span>]}<span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>)
</pre>

<h4 id="label-sql_expr">sql_expr<span><a href="#label-sql_expr">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#sql_expr and Hash#sql_expr treat the receiver as a conditions specifier, matching all of the conditions in the array.</p>

<pre class="ruby">{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]}.<span class="ruby-identifier">sql_expr</span>     <span class="ruby-comment"># SQL: a = 1 AND b IN (2, 3)</span>
[[<span class="ruby-value">:a</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">:b</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]]].<span class="ruby-identifier">sql_expr</span> <span class="ruby-comment"># SQL: a = 1 AND b IN (2, 3)</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]]
</pre>

<h4 id="label-sql_negate">sql_negate<span><a href="#label-sql_negate">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#sql_negate and Hash#sql_negate treat the receiver as a conditions specifier, matching none of the conditions in the array:</p>

<pre class="ruby">{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]}.<span class="ruby-identifier">sql_negate</span>       <span class="ruby-comment"># SQL: a != 1 AND b NOT IN (2, 3)</span>
[[<span class="ruby-value">:a</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">:b</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]]].<span class="ruby-identifier">sql_negate</span> <span class="ruby-comment"># SQL: a != 1 AND b NOT IN (2, 3)</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">negate</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>])
</pre>

<h4 id="label-sql_or">sql_or<span><a href="#label-sql_or">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#sql_or nd Hash#sql_or treat the receiver as a conditions specifier, matching any of the conditions in the array:</p>

<pre class="ruby">{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]}.<span class="ruby-identifier">sql_or</span>       <span class="ruby-comment"># SQL: a = 1 OR b IN (2, 3)</span>
[[<span class="ruby-value">:a</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">:b</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]]].<span class="ruby-identifier">sql_or</span> <span class="ruby-comment"># SQL: a = 1 OR b IN (2, 3)</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">or</span>(<span class="ruby-value">a:</span> <span class="ruby-value">1</span>, <span class="ruby-value">b:</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>])
</pre>

<h3 id="label-Array">Array<span><a href="#label-Array">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-sql_value_list">sql_value_list<span><a href="#label-sql_value_list">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#sql_value_list wraps the array in an array subclass, which <a href="../../classes/Sequel.html"><code>Sequel</code></a> will always treat as a value list and not a conditions specifier.  By default, <a href="../../classes/Sequel.html"><code>Sequel</code></a> treats arrays of two element arrays as a conditions specifier.</p>

<pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;(a, b) IN ?&#39;</span>, [[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]])                <span class="ruby-comment"># SQL: (a, b) IN ((1 = 2) AND (3 = 4))</span>
<span class="ruby-constant">DB</span>[<span class="ruby-value">:a</span>].<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;(a, b) IN ?&#39;</span>, [[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">sql_value_list</span>) <span class="ruby-comment"># SQL: (a, b) IN ((1, 2), (3, 4))</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">value_list</span>([[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]])
</pre>

<h4 id="label-sql_string_join">sql_string_join<span><a href="#label-sql_string_join">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Array#sql_string_join joins all of the elements in the array in an SQL string concatentation expression:</p>

<pre class="ruby">[<span class="ruby-value">:a</span>].<span class="ruby-identifier">sql_string_join</span>           <span class="ruby-comment"># SQL: a</span>
[<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>].<span class="ruby-identifier">sql_string_join</span>       <span class="ruby-comment"># SQL: a || b</span>
[<span class="ruby-value">:a</span>, <span class="ruby-string">&#39;b&#39;</span>].<span class="ruby-identifier">sql_string_join</span>      <span class="ruby-comment"># SQL: a || &#39;b&#39;</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">:b</span>].<span class="ruby-identifier">sql_string_join</span>(<span class="ruby-string">&#39; &#39;</span>) <span class="ruby-comment"># SQL: &#39;a&#39; || &#39; &#39; || b</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">join</span>([<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">:b</span>], <span class="ruby-string">&#39; &#39;</span>)
</pre>

<h3 id="label-Hash+-26+Symbol">Hash &amp; Symbol<span><a href="#label-Hash+-26+Symbol">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-26">&amp;<span><a href="#label-26">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Hash#& and Symbol#& return a <a href="../../classes/Sequel.html"><code>Sequel</code></a> boolean expression, matching the condition specified by the receiver and the condition specified by the given argument:</p>

<pre class="ruby"><span class="ruby-value">:a</span> <span class="ruby-operator">&amp;</span> <span class="ruby-value">:b</span>        <span class="ruby-comment"># SQL: a AND b</span>
{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>} <span class="ruby-operator">&amp;</span> <span class="ruby-value">:b</span>    <span class="ruby-comment"># SQL: a = 1 AND b</span>
{<span class="ruby-value">a:</span> <span class="ruby-keyword">true</span>} <span class="ruby-operator">&amp;</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a IS TRUE AND b</span>
</pre>

<p>Alternatives:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">a:</span> <span class="ruby-value">1</span>] <span class="ruby-operator">&amp;</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">&amp;</span>({<span class="ruby-value">a:</span> <span class="ruby-value">1</span>}, <span class="ruby-value">:b</span>)
</pre>

<h4 id="label-7C">|<span><a href="#label-7C">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Hash#| returns a <a href="../../classes/Sequel.html"><code>Sequel</code></a> boolean expression, matching the condition specified by the receiver or the condition specified by the given argument:</p>

<pre class="ruby"><span class="ruby-value">:a</span> <span class="ruby-operator">|</span> <span class="ruby-value">:b</span>        <span class="ruby-comment"># SQL: a OR b</span>
{<span class="ruby-value">a:</span> <span class="ruby-value">1</span>} <span class="ruby-operator">|</span> <span class="ruby-value">:b</span>    <span class="ruby-comment"># SQL: a = 1 OR b</span>
{<span class="ruby-value">a:</span> <span class="ruby-keyword">true</span>} <span class="ruby-operator">|</span> <span class="ruby-value">:b</span> <span class="ruby-comment"># SQL: a IS TRUE OR b</span>
</pre>

<p>Alternative:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-value">a:</span> <span class="ruby-value">1</span>] <span class="ruby-operator">|</span> <span class="ruby-value">:b</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">|</span>({<span class="ruby-value">a:</span> <span class="ruby-value">1</span>}, <span class="ruby-value">:b</span>)
</pre>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
